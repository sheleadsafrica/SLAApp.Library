/* tslint:disable */
/* eslint-disable */
/**
 * She Leads Africa API
 * She Leads Africa API. Combined endpoint of all services provided.
 *
 * OpenAPI spec version: v0
 * Contact: olpie101@github.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AchievementCreationRequest } from '../models';
import { AchievementCreationResponse } from '../models';
import { AchievementUpdateRequest } from '../models';
import { AchievementUpdateResponse } from '../models';
import { AnnouncementCreationRequest } from '../models';
import { AnnouncementCreationResponse } from '../models';
import { AnnouncementUpdateRequest } from '../models';
import { AnnouncementUpdateResponse } from '../models';
import { ApprovePendingWithdrawals } from '../models';
import { ApprovePendingWithdrawalsResponse } from '../models';
import { BlogPostCreationRequest } from '../models';
import { BlogPostCreationResponse } from '../models';
import { BlogPostUpdateRequest } from '../models';
import { BlogPostUpdateResponse } from '../models';
import { ChallengeCreationRequest } from '../models';
import { ChallengeCreationResponse } from '../models';
import { ChallengeUpdateRequest } from '../models';
import { ChallengeUpdateResponse } from '../models';
import { ChallengesResponse } from '../models';
import { CreateTodo } from '../models';
import { CreateTodoResponse } from '../models';
import { CreateVideoOfTheWeekResponse } from '../models';
import { FAQCreationRequest } from '../models';
import { FAQCreationResponse } from '../models';
import { FAQUpdateRequest } from '../models';
import { FAQUpdateResponse } from '../models';
import { FileUploadResponse } from '../models';
import { FinanceDictionaryEntryCreationRequest } from '../models';
import { FinanceDictionaryEntryCreationResponse } from '../models';
import { FinanceDictionaryEntryUpdateRequest } from '../models';
import { FinanceDictionaryEntryUpdateResponse } from '../models';
import { GoalTagCreationRequest } from '../models';
import { GoalTagCreationResponse } from '../models';
import { GoalTagUpdateRequest } from '../models';
import { GoalTagUpdateResponse } from '../models';
import { InvestmentCreationRequest } from '../models';
import { InvestmentCreationResponse } from '../models';
import { InvestmentUpdateRequest } from '../models';
import { InvestmentUpdateResponse } from '../models';
import { InvestmentsByUserIdResponse } from '../models';
import { LegalDocumentCreationRequest } from '../models';
import { LegalDocumentCreationResponse } from '../models';
import { LegalDocumentUpdateRequest } from '../models';
import { LegalDocumentUpdateResponse } from '../models';
import { ListTodosResponse } from '../models';
import { ListUsersResponse } from '../models';
import { ListWithdrawalsResponse } from '../models';
import { MoneyTipCreationRequest } from '../models';
import { MoneyTipCreationResponse } from '../models';
import { MoneyTipUpdateRequest } from '../models';
import { MoneyTipUpdateResponse } from '../models';
import { PortfolioAnalyticsResponse } from '../models';
import { ProblemDetails } from '../models';
import { SearchCustomersResponse } from '../models';
import { StashCreationRequest } from '../models';
import { StashCreationResponse } from '../models';
import { StashUpdateRequest } from '../models';
import { StashUpdateResponse } from '../models';
import { TotalSavingsByOwnerIdResponse } from '../models';
import { TransactionsByUserIdResponse } from '../models';
import { UpdateInvestmentHelpURL } from '../models';
import { UpdateInvestmentHelpURLResponse } from '../models';
import { UpdateTodo } from '../models';
import { UpdateTodoResponse } from '../models';
import { UpdateVideoOfTheWeekResponse } from '../models';
import { UpsertDailyRate } from '../models';
import { UpsertDailyRateResponse } from '../models';
import { UserAnalyticsResponse } from '../models';
import { VideoOfTheWeekRequest } from '../models';
import { WebinarPostCreationRequest } from '../models';
import { WebinarPostCreationResponse } from '../models';
import { WebinarPostUpdateRequest } from '../models';
import { WebinarPostUpdateResponse } from '../models';
/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ApprovePendingWithdrawals} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingWithdrawals: async (body?: ApprovePendingWithdrawals, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/withdrawals/approve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AchievementCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAchievement: async (body?: AchievementCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Announcement
         * @param {AnnouncementCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: async (body?: AnnouncementCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/announcement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new BlogPost
         * @param {BlogPostCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlogPost: async (body?: BlogPostCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/blog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChallengeCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChallenge: async (body?: ChallengeCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/challenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new FAQ
         * @param {FAQCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFAQ: async (body?: FAQCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/faq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Finance Dictionary Entry
         * @param {FinanceDictionaryEntryCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFinanceDictionaryEntry: async (body?: FinanceDictionaryEntryCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/finance-dictionary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GoalTagCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalTag: async (body?: GoalTagCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/goal-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InvestmentCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvestment: async (body?: InvestmentCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/investment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Legal Document
         * @param {LegalDocumentCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegalDocument: async (body?: LegalDocumentCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/legal-document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new MoneyTip
         * @param {MoneyTipCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMoneyTip: async (body?: MoneyTipCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/money-tip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StashCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStash: async (body?: StashCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/stash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTodo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTodo: async (body?: CreateTodo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/todo/admin/todo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a video of the week
         * @param {VideoOfTheWeekRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideoOfTheWeek: async (body?: VideoOfTheWeekRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/video-of-the-week`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new WebinarPost
         * @param {WebinarPostCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebinarPost: async (body?: WebinarPostCreationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/webinar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAchievement: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAchievement.');
            }
            const localVarPath = `/portfolio/admin/achievement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Announcement
         * @param {string} id Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAnnouncement.');
            }
            const localVarPath = `/media/admin/announcement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an BlogPost
         * @param {string} id BlogPost id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogPost: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteBlogPost.');
            }
            const localVarPath = `/media/admin/blog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an FAQ
         * @param {string} id faq id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFAQ: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFAQ.');
            }
            const localVarPath = `/media/admin/faq/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Finance Dictionary Entry
         * @param {string} id faq id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFinanceDictionaryEntry: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFinanceDictionaryEntry.');
            }
            const localVarPath = `/media/admin/finance-dictionary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalTag: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGoalTag.');
            }
            const localVarPath = `/portfolio/admin/goal-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Legal Document
         * @param {string} id legal document id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLegalDocument: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLegalDocument.');
            }
            const localVarPath = `/media/admin/legal-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an MoneyTip
         * @param {string} id MoneyTip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMoneyTip: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteMoneyTip.');
            }
            const localVarPath = `/media/admin/money-tip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an MoneyTip
         * @param {string} id MoneyTip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVideoOfTheWeek: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteVideoOfTheWeek.');
            }
            const localVarPath = `/media/admin/video-of-the-week/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an WebinarPost
         * @param {string} id WebinarPost id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebinarPost: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteWebinarPost.');
            }
            const localVarPath = `/media/admin/webinar/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovedWithdrawals: async (body?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/withdrawals/approved`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingWithdrawals: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/withdrawals/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalSavingsByOwnerId: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/totalSavings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChallenges: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/challenges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/admin/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTodos: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/todo/admin/todos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserInvestmentSet: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserInvestmentSet.');
            }
            const localVarPath = `/portfolio/admin/investments/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTransactions: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserTransactions.');
            }
            const localVarPath = `/portfolio/admin/transactions/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAnalytics: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [minAge] 
         * @param {number} [maxAge] 
         * @param {string} [monthlyEarnings] 
         * @param {string} [maritalStatus] 
         * @param {number} [minNumKids] 
         * @param {number} [maxNumKids] 
         * @param {string} [residenceType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomers: async (minAge?: number, maxAge?: number, monthlyEarnings?: string, maritalStatus?: string, minNumKids?: number, maxNumKids?: number, residenceType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/admin/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minAge !== undefined) {
                localVarQueryParameter['minAge'] = minAge;
            }

            if (maxAge !== undefined) {
                localVarQueryParameter['maxAge'] = maxAge;
            }

            if (monthlyEarnings !== undefined) {
                localVarQueryParameter['monthlyEarnings'] = monthlyEarnings;
            }

            if (maritalStatus !== undefined) {
                localVarQueryParameter['maritalStatus'] = maritalStatus;
            }

            if (minNumKids !== undefined) {
                localVarQueryParameter['minNumKids'] = minNumKids;
            }

            if (maxNumKids !== undefined) {
                localVarQueryParameter['maxNumKids'] = maxNumKids;
            }

            if (residenceType !== undefined) {
                localVarQueryParameter['residenceType'] = residenceType;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AchievementUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAchievement: async (id: string, body?: AchievementUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAchievement.');
            }
            const localVarPath = `/portfolio/admin/achievement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Announcement
         * @param {string} id Announcement id
         * @param {AnnouncementUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: async (id: string, body?: AnnouncementUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAnnouncement.');
            }
            const localVarPath = `/media/admin/announcement/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a BlogPost
         * @param {string} id BlogPost id
         * @param {BlogPostUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogPost: async (id: string, body?: BlogPostUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateBlogPost.');
            }
            const localVarPath = `/media/admin/blog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ChallengeUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChallenge: async (id: string, body?: ChallengeUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateChallenge.');
            }
            const localVarPath = `/portfolio/admin/challenge/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a FAQ
         * @param {string} id faq id
         * @param {FAQUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFAQ: async (id: string, body?: FAQUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFAQ.');
            }
            const localVarPath = `/media/admin/faq/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Finance Dictionary Entry
         * @param {string} id document id
         * @param {FinanceDictionaryEntryUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFinanceDictionaryEntry: async (id: string, body?: FinanceDictionaryEntryUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFinanceDictionaryEntry.');
            }
            const localVarPath = `/media/admin/finance-dictionary/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {GoalTagUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalTag: async (id: string, body?: GoalTagUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGoalTag.');
            }
            const localVarPath = `/portfolio/admin/goal-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InvestmentUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvestment: async (id: string, body?: InvestmentUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateInvestment.');
            }
            const localVarPath = `/portfolio/admin/investment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateInvestmentHelpURL} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvestmentsHelpUrl: async (body?: UpdateInvestmentHelpURL, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio/admin/help/investments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Legal Document
         * @param {string} id document id
         * @param {LegalDocumentUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLegalDocument: async (id: string, body?: LegalDocumentUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLegalDocument.');
            }
            const localVarPath = `/media/admin/legal-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a MoneyTip
         * @param {string} id MoneyTip id
         * @param {MoneyTipUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMoneyTip: async (id: string, body?: MoneyTipUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateMoneyTip.');
            }
            const localVarPath = `/media/admin/money-tip/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StashUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStash: async (id: string, body?: StashUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateStash.');
            }
            const localVarPath = `/portfolio/admin/stash/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTodo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTodo: async (id: string, body?: UpdateTodo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTodo.');
            }
            const localVarPath = `/todo/admin/todo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a video of the week
         * @param {string} id video of the week id
         * @param {VideoOfTheWeekRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoOfTheWeek: async (id: string, body?: VideoOfTheWeekRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateVideoOfTheWeek.');
            }
            const localVarPath = `/media/admin/video-of-the-week/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a WebinarPost
         * @param {string} id WebinarPost id
         * @param {WebinarPostUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebinarPost: async (id: string, body?: WebinarPostUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateWebinarPost.');
            }
            const localVarPath = `/media/admin/webinar/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Upload file
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (file?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media/admin/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpsertDailyRate} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertInvestmentRate: async (id: string, body?: UpsertDailyRate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling upsertInvestmentRate.');
            }
            const localVarPath = `/portfolio/admin/investment/{id}/rate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnalytics: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/admin/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ApprovePendingWithdrawals} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePendingWithdrawals(body?: ApprovePendingWithdrawals, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovePendingWithdrawalsResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).approvePendingWithdrawals(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AchievementCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAchievement(body?: AchievementCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchievementCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createAchievement(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Announcement
         * @param {AnnouncementCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnouncement(body?: AnnouncementCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createAnnouncement(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new BlogPost
         * @param {BlogPostCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlogPost(body?: BlogPostCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createBlogPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ChallengeCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChallenge(body?: ChallengeCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChallengeCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createChallenge(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new FAQ
         * @param {FAQCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFAQ(body?: FAQCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FAQCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createFAQ(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Finance Dictionary Entry
         * @param {FinanceDictionaryEntryCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFinanceDictionaryEntry(body?: FinanceDictionaryEntryCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinanceDictionaryEntryCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createFinanceDictionaryEntry(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {GoalTagCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGoalTag(body?: GoalTagCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalTagCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createGoalTag(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InvestmentCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvestment(body?: InvestmentCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createInvestment(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Legal Document
         * @param {LegalDocumentCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLegalDocument(body?: LegalDocumentCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LegalDocumentCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createLegalDocument(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new MoneyTip
         * @param {MoneyTipCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMoneyTip(body?: MoneyTipCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoneyTipCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createMoneyTip(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {StashCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStash(body?: StashCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StashCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createStash(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateTodo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTodo(body?: CreateTodo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTodoResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createTodo(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a video of the week
         * @param {VideoOfTheWeekRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVideoOfTheWeek(body?: VideoOfTheWeekRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVideoOfTheWeekResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createVideoOfTheWeek(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new WebinarPost
         * @param {WebinarPostCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebinarPost(body?: WebinarPostCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebinarPostCreationResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).createWebinarPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAchievement(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteAchievement(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Announcement
         * @param {string} id Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnouncement(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteAnnouncement(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an BlogPost
         * @param {string} id BlogPost id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogPost(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteBlogPost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an FAQ
         * @param {string} id faq id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFAQ(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteFAQ(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Finance Dictionary Entry
         * @param {string} id faq id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFinanceDictionaryEntry(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteFinanceDictionaryEntry(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGoalTag(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteGoalTag(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Legal Document
         * @param {string} id legal document id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLegalDocument(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteLegalDocument(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an MoneyTip
         * @param {string} id MoneyTip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMoneyTip(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteMoneyTip(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an MoneyTip
         * @param {string} id MoneyTip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVideoOfTheWeek(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteVideoOfTheWeek(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an WebinarPost
         * @param {string} id WebinarPost id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebinarPost(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).deleteWebinarPost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovedWithdrawals(body?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWithdrawalsResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).getApprovedWithdrawals(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingWithdrawals(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWithdrawalsResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).getPendingWithdrawals(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalSavingsByOwnerId(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TotalSavingsByOwnerIdResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).getTotalSavingsByOwnerId(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChallenges(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChallengesResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).listChallenges(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUsersResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).listCustomers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTodos(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTodosResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).listTodos(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserInvestmentSet(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentsByUserIdResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).listUserInvestmentSet(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserTransactions(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsByUserIdResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).listUserTransactions(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioAnalytics(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioAnalyticsResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).portfolioAnalytics(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [minAge] 
         * @param {number} [maxAge] 
         * @param {string} [monthlyEarnings] 
         * @param {string} [maritalStatus] 
         * @param {number} [minNumKids] 
         * @param {number} [maxNumKids] 
         * @param {string} [residenceType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCustomers(minAge?: number, maxAge?: number, monthlyEarnings?: string, maritalStatus?: string, minNumKids?: number, maxNumKids?: number, residenceType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchCustomersResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).searchCustomers(minAge, maxAge, monthlyEarnings, maritalStatus, minNumKids, maxNumKids, residenceType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {AchievementUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAchievement(id: string, body?: AchievementUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchievementUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateAchievement(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Announcement
         * @param {string} id Announcement id
         * @param {AnnouncementUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnouncement(id: string, body?: AnnouncementUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateAnnouncement(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a BlogPost
         * @param {string} id BlogPost id
         * @param {BlogPostUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlogPost(id: string, body?: BlogPostUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPostUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateBlogPost(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ChallengeUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChallenge(id: string, body?: ChallengeUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChallengeUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateChallenge(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a FAQ
         * @param {string} id faq id
         * @param {FAQUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFAQ(id: string, body?: FAQUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FAQUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateFAQ(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Finance Dictionary Entry
         * @param {string} id document id
         * @param {FinanceDictionaryEntryUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFinanceDictionaryEntry(id: string, body?: FinanceDictionaryEntryUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinanceDictionaryEntryUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateFinanceDictionaryEntry(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {GoalTagUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoalTag(id: string, body?: GoalTagUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalTagUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateGoalTag(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {InvestmentUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvestment(id: string, body?: InvestmentUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvestmentUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateInvestment(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateInvestmentHelpURL} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvestmentsHelpUrl(body?: UpdateInvestmentHelpURL, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateInvestmentHelpURLResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateInvestmentsHelpUrl(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Legal Document
         * @param {string} id document id
         * @param {LegalDocumentUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLegalDocument(id: string, body?: LegalDocumentUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LegalDocumentUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateLegalDocument(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a MoneyTip
         * @param {string} id MoneyTip id
         * @param {MoneyTipUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMoneyTip(id: string, body?: MoneyTipUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoneyTipUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateMoneyTip(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StashUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStash(id: string, body?: StashUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StashUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateStash(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTodo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTodo(id: string, body?: UpdateTodo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateTodoResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateTodo(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a video of the week
         * @param {string} id video of the week id
         * @param {VideoOfTheWeekRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVideoOfTheWeek(id: string, body?: VideoOfTheWeekRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateVideoOfTheWeekResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateVideoOfTheWeek(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a WebinarPost
         * @param {string} id WebinarPost id
         * @param {WebinarPostUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebinarPost(id: string, body?: WebinarPostUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebinarPostUpdateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updateWebinarPost(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Upload file
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(file?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).uploadFile(file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpsertDailyRate} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertInvestmentRate(id: string, body?: UpsertDailyRate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertDailyRateResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).upsertInvestmentRate(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAnalytics(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAnalyticsResponse>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).userAnalytics(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ApprovePendingWithdrawals} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePendingWithdrawals(body?: ApprovePendingWithdrawals, options?: any): AxiosPromise<ApprovePendingWithdrawalsResponse> {
            return AdminApiFp(configuration).approvePendingWithdrawals(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AchievementCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAchievement(body?: AchievementCreationRequest, options?: any): AxiosPromise<AchievementCreationResponse> {
            return AdminApiFp(configuration).createAchievement(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Announcement
         * @param {AnnouncementCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(body?: AnnouncementCreationRequest, options?: any): AxiosPromise<AnnouncementCreationResponse> {
            return AdminApiFp(configuration).createAnnouncement(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new BlogPost
         * @param {BlogPostCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlogPost(body?: BlogPostCreationRequest, options?: any): AxiosPromise<BlogPostCreationResponse> {
            return AdminApiFp(configuration).createBlogPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChallengeCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChallenge(body?: ChallengeCreationRequest, options?: any): AxiosPromise<ChallengeCreationResponse> {
            return AdminApiFp(configuration).createChallenge(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new FAQ
         * @param {FAQCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFAQ(body?: FAQCreationRequest, options?: any): AxiosPromise<FAQCreationResponse> {
            return AdminApiFp(configuration).createFAQ(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Finance Dictionary Entry
         * @param {FinanceDictionaryEntryCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFinanceDictionaryEntry(body?: FinanceDictionaryEntryCreationRequest, options?: any): AxiosPromise<FinanceDictionaryEntryCreationResponse> {
            return AdminApiFp(configuration).createFinanceDictionaryEntry(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GoalTagCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoalTag(body?: GoalTagCreationRequest, options?: any): AxiosPromise<GoalTagCreationResponse> {
            return AdminApiFp(configuration).createGoalTag(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InvestmentCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvestment(body?: InvestmentCreationRequest, options?: any): AxiosPromise<InvestmentCreationResponse> {
            return AdminApiFp(configuration).createInvestment(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new Legal Document
         * @param {LegalDocumentCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegalDocument(body?: LegalDocumentCreationRequest, options?: any): AxiosPromise<LegalDocumentCreationResponse> {
            return AdminApiFp(configuration).createLegalDocument(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new MoneyTip
         * @param {MoneyTipCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMoneyTip(body?: MoneyTipCreationRequest, options?: any): AxiosPromise<MoneyTipCreationResponse> {
            return AdminApiFp(configuration).createMoneyTip(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StashCreationRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStash(body?: StashCreationRequest, options?: any): AxiosPromise<StashCreationResponse> {
            return AdminApiFp(configuration).createStash(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTodo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTodo(body?: CreateTodo, options?: any): AxiosPromise<CreateTodoResponse> {
            return AdminApiFp(configuration).createTodo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a video of the week
         * @param {VideoOfTheWeekRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideoOfTheWeek(body?: VideoOfTheWeekRequest, options?: any): AxiosPromise<CreateVideoOfTheWeekResponse> {
            return AdminApiFp(configuration).createVideoOfTheWeek(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Create a new WebinarPost
         * @param {WebinarPostCreationRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebinarPost(body?: WebinarPostCreationRequest, options?: any): AxiosPromise<WebinarPostCreationResponse> {
            return AdminApiFp(configuration).createWebinarPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAchievement(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteAchievement(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Announcement
         * @param {string} id Announcement id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteAnnouncement(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an BlogPost
         * @param {string} id BlogPost id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogPost(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteBlogPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an FAQ
         * @param {string} id faq id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFAQ(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteFAQ(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Finance Dictionary Entry
         * @param {string} id faq id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFinanceDictionaryEntry(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteFinanceDictionaryEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoalTag(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteGoalTag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an Legal Document
         * @param {string} id legal document id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLegalDocument(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteLegalDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an MoneyTip
         * @param {string} id MoneyTip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMoneyTip(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteMoneyTip(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an MoneyTip
         * @param {string} id MoneyTip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVideoOfTheWeek(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteVideoOfTheWeek(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete an WebinarPost
         * @param {string} id WebinarPost id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebinarPost(id: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).deleteWebinarPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovedWithdrawals(body?: number, options?: any): AxiosPromise<ListWithdrawalsResponse> {
            return AdminApiFp(configuration).getApprovedWithdrawals(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingWithdrawals(options?: any): AxiosPromise<ListWithdrawalsResponse> {
            return AdminApiFp(configuration).getPendingWithdrawals(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalSavingsByOwnerId(userId?: string, options?: any): AxiosPromise<TotalSavingsByOwnerIdResponse> {
            return AdminApiFp(configuration).getTotalSavingsByOwnerId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChallenges(options?: any): AxiosPromise<ChallengesResponse> {
            return AdminApiFp(configuration).listChallenges(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers(options?: any): AxiosPromise<ListUsersResponse> {
            return AdminApiFp(configuration).listCustomers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTodos(options?: any): AxiosPromise<ListTodosResponse> {
            return AdminApiFp(configuration).listTodos(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserInvestmentSet(userId: string, options?: any): AxiosPromise<InvestmentsByUserIdResponse> {
            return AdminApiFp(configuration).listUserInvestmentSet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTransactions(userId: string, options?: any): AxiosPromise<TransactionsByUserIdResponse> {
            return AdminApiFp(configuration).listUserTransactions(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAnalytics(options?: any): AxiosPromise<PortfolioAnalyticsResponse> {
            return AdminApiFp(configuration).portfolioAnalytics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [minAge] 
         * @param {number} [maxAge] 
         * @param {string} [monthlyEarnings] 
         * @param {string} [maritalStatus] 
         * @param {number} [minNumKids] 
         * @param {number} [maxNumKids] 
         * @param {string} [residenceType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomers(minAge?: number, maxAge?: number, monthlyEarnings?: string, maritalStatus?: string, minNumKids?: number, maxNumKids?: number, residenceType?: string, options?: any): AxiosPromise<SearchCustomersResponse> {
            return AdminApiFp(configuration).searchCustomers(minAge, maxAge, monthlyEarnings, maritalStatus, minNumKids, maxNumKids, residenceType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {AchievementUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAchievement(id: string, body?: AchievementUpdateRequest, options?: any): AxiosPromise<AchievementUpdateResponse> {
            return AdminApiFp(configuration).updateAchievement(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Announcement
         * @param {string} id Announcement id
         * @param {AnnouncementUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(id: string, body?: AnnouncementUpdateRequest, options?: any): AxiosPromise<AnnouncementUpdateResponse> {
            return AdminApiFp(configuration).updateAnnouncement(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a BlogPost
         * @param {string} id BlogPost id
         * @param {BlogPostUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlogPost(id: string, body?: BlogPostUpdateRequest, options?: any): AxiosPromise<BlogPostUpdateResponse> {
            return AdminApiFp(configuration).updateBlogPost(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ChallengeUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChallenge(id: string, body?: ChallengeUpdateRequest, options?: any): AxiosPromise<ChallengeUpdateResponse> {
            return AdminApiFp(configuration).updateChallenge(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a FAQ
         * @param {string} id faq id
         * @param {FAQUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFAQ(id: string, body?: FAQUpdateRequest, options?: any): AxiosPromise<FAQUpdateResponse> {
            return AdminApiFp(configuration).updateFAQ(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Finance Dictionary Entry
         * @param {string} id document id
         * @param {FinanceDictionaryEntryUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFinanceDictionaryEntry(id: string, body?: FinanceDictionaryEntryUpdateRequest, options?: any): AxiosPromise<FinanceDictionaryEntryUpdateResponse> {
            return AdminApiFp(configuration).updateFinanceDictionaryEntry(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {GoalTagUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoalTag(id: string, body?: GoalTagUpdateRequest, options?: any): AxiosPromise<GoalTagUpdateResponse> {
            return AdminApiFp(configuration).updateGoalTag(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {InvestmentUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvestment(id: string, body?: InvestmentUpdateRequest, options?: any): AxiosPromise<InvestmentUpdateResponse> {
            return AdminApiFp(configuration).updateInvestment(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateInvestmentHelpURL} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvestmentsHelpUrl(body?: UpdateInvestmentHelpURL, options?: any): AxiosPromise<UpdateInvestmentHelpURLResponse> {
            return AdminApiFp(configuration).updateInvestmentsHelpUrl(body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a Legal Document
         * @param {string} id document id
         * @param {LegalDocumentUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLegalDocument(id: string, body?: LegalDocumentUpdateRequest, options?: any): AxiosPromise<LegalDocumentUpdateResponse> {
            return AdminApiFp(configuration).updateLegalDocument(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a MoneyTip
         * @param {string} id MoneyTip id
         * @param {MoneyTipUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMoneyTip(id: string, body?: MoneyTipUpdateRequest, options?: any): AxiosPromise<MoneyTipUpdateResponse> {
            return AdminApiFp(configuration).updateMoneyTip(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StashUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStash(id: string, body?: StashUpdateRequest, options?: any): AxiosPromise<StashUpdateResponse> {
            return AdminApiFp(configuration).updateStash(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTodo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTodo(id: string, body?: UpdateTodo, options?: any): AxiosPromise<UpdateTodoResponse> {
            return AdminApiFp(configuration).updateTodo(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a video of the week
         * @param {string} id video of the week id
         * @param {VideoOfTheWeekRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoOfTheWeek(id: string, body?: VideoOfTheWeekRequest, options?: any): AxiosPromise<UpdateVideoOfTheWeekResponse> {
            return AdminApiFp(configuration).updateVideoOfTheWeek(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update a WebinarPost
         * @param {string} id WebinarPost id
         * @param {WebinarPostUpdateRequest} [body] request values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebinarPost(id: string, body?: WebinarPostUpdateRequest, options?: any): AxiosPromise<WebinarPostUpdateResponse> {
            return AdminApiFp(configuration).updateWebinarPost(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Upload file
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(file?: string, options?: any): AxiosPromise<FileUploadResponse> {
            return AdminApiFp(configuration).uploadFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpsertDailyRate} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertInvestmentRate(id: string, body?: UpsertDailyRate, options?: any): AxiosPromise<UpsertDailyRateResponse> {
            return AdminApiFp(configuration).upsertInvestmentRate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAnalytics(options?: any): AxiosPromise<UserAnalyticsResponse> {
            return AdminApiFp(configuration).userAnalytics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {ApprovePendingWithdrawals} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public approvePendingWithdrawals(body?: ApprovePendingWithdrawals, options?: any) {
        return AdminApiFp(this.configuration).approvePendingWithdrawals(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {AchievementCreationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createAchievement(body?: AchievementCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createAchievement(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a new Announcement
     * @param {AnnouncementCreationRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createAnnouncement(body?: AnnouncementCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createAnnouncement(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a new BlogPost
     * @param {BlogPostCreationRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createBlogPost(body?: BlogPostCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createBlogPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {ChallengeCreationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createChallenge(body?: ChallengeCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createChallenge(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a new FAQ
     * @param {FAQCreationRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createFAQ(body?: FAQCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createFAQ(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a new Finance Dictionary Entry
     * @param {FinanceDictionaryEntryCreationRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createFinanceDictionaryEntry(body?: FinanceDictionaryEntryCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createFinanceDictionaryEntry(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {GoalTagCreationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createGoalTag(body?: GoalTagCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createGoalTag(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {InvestmentCreationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createInvestment(body?: InvestmentCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createInvestment(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a new Legal Document
     * @param {LegalDocumentCreationRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createLegalDocument(body?: LegalDocumentCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createLegalDocument(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a new MoneyTip
     * @param {MoneyTipCreationRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createMoneyTip(body?: MoneyTipCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createMoneyTip(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {StashCreationRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createStash(body?: StashCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createStash(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {CreateTodo} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createTodo(body?: CreateTodo, options?: any) {
        return AdminApiFp(this.configuration).createTodo(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a video of the week
     * @param {VideoOfTheWeekRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createVideoOfTheWeek(body?: VideoOfTheWeekRequest, options?: any) {
        return AdminApiFp(this.configuration).createVideoOfTheWeek(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Create a new WebinarPost
     * @param {WebinarPostCreationRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createWebinarPost(body?: WebinarPostCreationRequest, options?: any) {
        return AdminApiFp(this.configuration).createWebinarPost(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAchievement(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteAchievement(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an Announcement
     * @param {string} id Announcement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAnnouncement(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteAnnouncement(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an BlogPost
     * @param {string} id BlogPost id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteBlogPost(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteBlogPost(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an FAQ
     * @param {string} id faq id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteFAQ(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteFAQ(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an Finance Dictionary Entry
     * @param {string} id faq id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteFinanceDictionaryEntry(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteFinanceDictionaryEntry(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteGoalTag(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteGoalTag(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an Legal Document
     * @param {string} id legal document id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteLegalDocument(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteLegalDocument(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an MoneyTip
     * @param {string} id MoneyTip id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteMoneyTip(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteMoneyTip(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an MoneyTip
     * @param {string} id MoneyTip id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteVideoOfTheWeek(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteVideoOfTheWeek(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete an WebinarPost
     * @param {string} id WebinarPost id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteWebinarPost(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteWebinarPost(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getApprovedWithdrawals(body?: number, options?: any) {
        return AdminApiFp(this.configuration).getApprovedWithdrawals(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getPendingWithdrawals(options?: any) {
        return AdminApiFp(this.configuration).getPendingWithdrawals(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getTotalSavingsByOwnerId(userId?: string, options?: any) {
        return AdminApiFp(this.configuration).getTotalSavingsByOwnerId(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listChallenges(options?: any) {
        return AdminApiFp(this.configuration).listChallenges(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listCustomers(options?: any) {
        return AdminApiFp(this.configuration).listCustomers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listTodos(options?: any) {
        return AdminApiFp(this.configuration).listTodos(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listUserInvestmentSet(userId: string, options?: any) {
        return AdminApiFp(this.configuration).listUserInvestmentSet(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listUserTransactions(userId: string, options?: any) {
        return AdminApiFp(this.configuration).listUserTransactions(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public portfolioAnalytics(options?: any) {
        return AdminApiFp(this.configuration).portfolioAnalytics(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} [minAge] 
     * @param {number} [maxAge] 
     * @param {string} [monthlyEarnings] 
     * @param {string} [maritalStatus] 
     * @param {number} [minNumKids] 
     * @param {number} [maxNumKids] 
     * @param {string} [residenceType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public searchCustomers(minAge?: number, maxAge?: number, monthlyEarnings?: string, maritalStatus?: string, minNumKids?: number, maxNumKids?: number, residenceType?: string, options?: any) {
        return AdminApiFp(this.configuration).searchCustomers(minAge, maxAge, monthlyEarnings, maritalStatus, minNumKids, maxNumKids, residenceType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {AchievementUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateAchievement(id: string, body?: AchievementUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateAchievement(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a Announcement
     * @param {string} id Announcement id
     * @param {AnnouncementUpdateRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateAnnouncement(id: string, body?: AnnouncementUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateAnnouncement(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a BlogPost
     * @param {string} id BlogPost id
     * @param {BlogPostUpdateRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateBlogPost(id: string, body?: BlogPostUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateBlogPost(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {ChallengeUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateChallenge(id: string, body?: ChallengeUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateChallenge(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a FAQ
     * @param {string} id faq id
     * @param {FAQUpdateRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateFAQ(id: string, body?: FAQUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateFAQ(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a Finance Dictionary Entry
     * @param {string} id document id
     * @param {FinanceDictionaryEntryUpdateRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateFinanceDictionaryEntry(id: string, body?: FinanceDictionaryEntryUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateFinanceDictionaryEntry(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {GoalTagUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateGoalTag(id: string, body?: GoalTagUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateGoalTag(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {InvestmentUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateInvestment(id: string, body?: InvestmentUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateInvestment(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {UpdateInvestmentHelpURL} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateInvestmentsHelpUrl(body?: UpdateInvestmentHelpURL, options?: any) {
        return AdminApiFp(this.configuration).updateInvestmentsHelpUrl(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a Legal Document
     * @param {string} id document id
     * @param {LegalDocumentUpdateRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateLegalDocument(id: string, body?: LegalDocumentUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateLegalDocument(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a MoneyTip
     * @param {string} id MoneyTip id
     * @param {MoneyTipUpdateRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateMoneyTip(id: string, body?: MoneyTipUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateMoneyTip(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {StashUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateStash(id: string, body?: StashUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateStash(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {UpdateTodo} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateTodo(id: string, body?: UpdateTodo, options?: any) {
        return AdminApiFp(this.configuration).updateTodo(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a video of the week
     * @param {string} id video of the week id
     * @param {VideoOfTheWeekRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateVideoOfTheWeek(id: string, body?: VideoOfTheWeekRequest, options?: any) {
        return AdminApiFp(this.configuration).updateVideoOfTheWeek(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update a WebinarPost
     * @param {string} id WebinarPost id
     * @param {WebinarPostUpdateRequest} [body] request values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateWebinarPost(id: string, body?: WebinarPostUpdateRequest, options?: any) {
        return AdminApiFp(this.configuration).updateWebinarPost(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This can only be done by the logged in user.
     * @summary Upload file
     * @param {string} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public uploadFile(file?: string, options?: any) {
        return AdminApiFp(this.configuration).uploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {UpsertDailyRate} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public upsertInvestmentRate(id: string, body?: UpsertDailyRate, options?: any) {
        return AdminApiFp(this.configuration).upsertInvestmentRate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public userAnalytics(options?: any) {
        return AdminApiFp(this.configuration).userAnalytics(options).then((request) => request(this.axios, this.basePath));
    }
}
